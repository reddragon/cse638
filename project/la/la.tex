\documentclass{article}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{url}
\usepackage{color}
\usepackage{savetrees}
\usepackage{listings}
\usetikzlibrary{shapes}


\linespread{1.4}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1.9ex plus 0.5ex minus 0.2ex}

\title{A Simple Solution to the Level Ancestor Problem}

\author{Gaurav Menghani \& Dhruv Matani}

\begin{document}
\maketitle


\begin{abstract}

In this paper, we present a simple $O\mathrm{<}n, \log{n}\mathrm{>}$
approach to solving the \textit{Level Ancestor Problem}.

\end{abstract}


\section{Level Ancestor Problem}
We perform a \textit{pre-order traversal} of the tree we are
interested in, and label the nodes in increasing order of their first
appearance in the traversal. We maintain a \textit{dynamic array} for
each level in the tree, and as and when we see a node for the first
time, we insert the node into the \textit{dynamic table} at that
level. The \textit{value} associated with each node is an integer,
which keeps increasing as we follow the traversal along the treem and
a pointer to the node itself. It is easy to see that the labels in
each vector would be in strictly \textit{increasing} order.

Now, if we wish to answer the $l^{th}$ Level Ancestor query for a node
with \textit{value} $k$, we can index into the vector for the $l^{th}$
level, and perform a binary search for the greatest label, smaller
than $k$. This value is called the \textit{lower bound} of $k$. The
reason why this works is that the ancestor at level $l$ would have
been visited before the node labelled $n$, and hence have a smaller
label. Any other node on level $l$ would have either been visited
before the correct ancestor, or after the node $k$. Using Binary
Search, we can thus answer the Level Ancestor query in $O(\log{n})$
time, with $O(n)$ extra and $O(n)$ initial preprocessing.

\end{document}
